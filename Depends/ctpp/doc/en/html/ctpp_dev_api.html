<html>
<head>
	<meta http-equiv=Content-Type content="text/html; charset=iso-8859-1">
	<title>CT++ API</title>
	<link rel=stylesheet type=text/css href=ctpp.css>
</head>
<body bgcolor=white text=black>
<h3>CT++ API</h3><br>
<h4>Class <span class=c_code>template_text</span></h4>
<style>
.c1 {color:red; }
.c2 {color:blue; }
.c3 {color:green; }
.c4 {color:orange; }
.c5 {color:olive; }
</style>
<span class=c_code><br>
<span class=c5>// Constructor</span><br>
template_text(udf_fn_factory * pFactory = NULL,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=c2>const int</span> iLine = <span class=c1>1</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=c2>const int</span> iPos = <span class=c1>1</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=c2>const int</span> iTabLength = <span class=c1>9</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=c2>const bool</span> bDebug = <span class=c1>false</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=c2>const bool</span> bStrict = <span class=c1>true</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=c2>const bool</span> bLoopContextVars = <span class=c1>false</span>,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=c2>const bool</span> bGlobalVars = <span class=c1>false</span>);<br><br>
</span>
where:<br>
<span class=c_code>pFactory</span> -  factory of the objects of the user functions<br><br>

<span class=c_code>iLine</span> -  the number of the line of template (default - 1)<br>
<span class=c_code>iPos</span> - position in the line of template  (default - 1)<br>
<span class=c_code>iTabLength</span> - size of the symbol of tabulation in spaces (default 9)<br><br>
These three parameters are used as initial values in the system of the syntax analysis of template.<br><br>

<span class=c_code>bDebug</span> - enable or disable debug (default off)<br>
<span class=c_code>bStrict</span> - strict syntax checking (after construction <span class=op>&lt;TMPL_</span>must follow the operator of template engine CT++, default on)<br><br>

<span class=c_code>bLoopContextVars</span> - use of contextual variables in the cycle  (default off)<br>
<span class=c_code>bGlobalVars</span> - use of global variables in the cycle (default off)<br>
<br>
<span class=c_code><br>
<span class=c5>// Getting Factory</span><br>
udf_fn_factory * get_fn_factory();<br><br>
</span>
Getting  the factory of objects.  If the object of template engine создается без фабрики объектов,is created without the factory of objects, object independently creates its internal factory with the set of standard functions.<br>
Method <span class=c_code>get_fn_factory</span>serves for obtaining the pointer to the factory<br><br>

<span class=c_code>
<span class=c5>// Setting IncludeDir</span><br>
<span class=c2>void</span> set_include_dir(<span class=c2>const</span> v_include_dir &vIncludeDir);<br><br>
</span>
где:<br>
<span class=c_code>vIncludeDir</span> - list of catalogs for the i of the investments through <nobr><span class=op>&lt;TMPL_include filename.tmpl&gt;</span></nobr><br><br>
If path to the file name does not begin from the slash, file consecutively searches for in all catalogs from <span class=c_code>vIncludeDir</span>.
But if path begins from the slash, path is checked against the entry in <span class=c_code>vIncludeDir</span>.
If path is not found in <span class=c_code>vIncludeDir</span> or it is not possible to open file, is generated exception <span class=c4>std::logic_error</span>.<br><br>

<span class=c_code>
<span class=c5>// Parse the template</span><br>
<span class=c2>void</span> parse(<span class=c2>const</span> <span class=c4>std::string</span> & sData);<br><br>
<span class=c2>void</span> parse(<span class=c4>std::string::const_iterator</span> & sDataBegin, <span class=c4>std::string::const_iterator</span> & sDataEnd);<br><br>
</span>
Overloaded method. To the entrance are obtained the beginning and the end of the sequence of the symbols, which are been template, or the string of symbols.
<br><br>

<span class=c_code>
<span class=c5>// Insert the parameters</span><br>
<span class=c2>void</span> param(param_data * pParamData);<br><br>
</span>
Insert of the parameters into the template.<br><br>

<span class=c_code>
<span class=c5>// Result output</span><br>
<span class=c4>std::string</span> & output();<br><br>
</span>
Result output to user.<br><br>

<span class=c_code>
<span class=c5>// Cleaning the template</span><br>
<span class=c2>void</span> clear_template();<br><br>
</span>
Cleaning template.<br><br>

<span class=c_code>
<span class=c5>// Destructor</span><br>
~template_text() <span class=c1>throw();</span><br><br>
</span><br>

<h4>Class <span class=c_code>loader_base</span></h4>
Base class for creating its own includes loader.<br>

<span class=c_code>
<span class=c5>// Load file</span><br>
<span class=c1>virtual</span> <span class=c2>void</span> load_file(<span class=c2>const</span> <span class=c4>std::string</span> &sFileName);<br><br>
</span><br>
Method obtains the complete name of file.<br><br>

<span class=c_code>
<span class=c5>// Getting data</span><br>
<span class=c1>virtual</span> <span class=c4>std::string</span> & get_data();<br><br>
</span><br>
Returns contents of opened file.<br><br>

<span class=c_code>
<span class=c5>// Destructor</span><br>
<span class=c1>virtual</span> ~loader_base() <span class=c1>throw();</span><br><br>
</span><br>

<h4>Class <span class=c_code>udf_fn_factory</span></h4>

Class-installerof the user defined functions.<br><br>

<span class=c_code>
<span class=c5>// Installation of user defined function</span><br>
<span class=c2>void</span> install_udf_fn(<span class=c2>const</span> <span class=c4>std::string</span> &sFunctionName, udf_fn * pUDFFn);<br><br>
</span>
Puts the object of function in the factory of objects created previously. First parameter - name of function in the template. Second parameter - pointer to the object of function.<br><br>

<span class=c_code>
<span class=c5>// Removind of user defined function</span><br>
<span class=c2>void</span> remove_udf_fn(<span class=c2>const</span> <span class=c4>std::string</span> &sFunctionName);<br><br>
</span>
Removes user defined function from the factory of objects. First parameter - name of function in the template.<br><br>

<span class=c_code>
<span class=c5>// Getting pointer to the function</span><br>
udf_fn * get(<span class=c2>const</span> <span class=c4>std::string</span> &sFunctionName);<br><br>
</span>
First parameter - name of function in the template.<br><br>

<span class=c_code>
<span class=c5>// Clear factory</span><br>
<span class=c2>void</span> clear();<br><br>
</span>
Removes all function from the factoryu, including standard functions set.<br><br>

<span class=c_code>
<span class=c5>// Destructor</span><br>
<span class=c1>virtual</span> ~udf_fn_factory();<br><br>
</span><br>

<h4>Class <span class=c_code>param_data</span></h4>
This class is used for the transfer of parameters to template engine.<br><br>

Determinations of essences.<br>
In template engine CTPP there are three types of the data: line, array and hash are given. Below the determination of these types:<br>

<span class=c_code>
<span class=c5>// String</span><br>
typedef <span class=c4>std::string</span> t_param_str;<br><br>
<span class=c5>// Array</span><br>
typedef <span class=c4>std::vector</span>&lt;param_data *&gt; t_param_array;<br><br>
<span class=c5>// Hash</span><br>
typedef <span class=c4>std::map</span>&lt;<span class=c4>std::string</span>, param_data *&gt; t_param_hash;<br><br>
</span><br>

For the indication of the type of object serves the enumeration  <span class=c_code>e_value_type</span>:<br>
<span class=c_code>
<span class=c2>enum</span> e_value_type { VAR, ARRAY, HASH };<br><br>
</span>

<span class=c_code>
<span class=c5>// Constructor</span><br>
param_data(e_value_type eIType = VAR);<br><br>
</span>
Is created object in by the assigned type.<br><br>

<span class=c_code>
<span class=c5>// Pointer to the VAL</span><br>
t_param_str   *      val();<br><br>
</span>
Returns pointer to the object of the type "line". If this method inquires in the object with the type, different from VAR, is generated exception std::logic_error.<br><br>

<span class=c_code>
<span class=c5>// Pointer to the ARRAY</span><br>
t_param_array *      array();<br><br>
</span>
Returns pointer to the object of the type "array". If this method inquires in the object with the type, different from ARRAY, is generated exception std::logic_error.<br><br>

<span class=c_code>
<span class=c5>// Pointer to the HASH</span><br>
t_param_hash  *      hash();<br><br>
</span>
Returns pointer to the object of the type "hash". If this method inquires in the object with the type, different from HASH,  is generated exception std::logic_error.<br><br>

<span class=c_code>
<span class=c5>// Type of the variable</span><br>
e_value_type get_value_type();<br><br>
</span>
Getting the type of object.<br><br>

<span class=c_code>
<span class=c5>// Insert variable into hash</span><br>
param_data * hash_insert_new_var(<span class=c2>const</span> <span class=c4>std::string</span> &sKey, const <span class=c4>std::string</span> &sValue);<br><br>
</span>
Insert pair "key =&gt; value" в hash. Returns pointer to the created variable.<br><br>

<span class=c_code>
<span class=c5>// Insert array into </span><br>
param_data * hash_insert_new_array(<span class=c2>const</span> <span class=c4>std::string</span> &sKey);<br><br>
</span>
Insert pair "key  =&gt; array" в hash. Returns pointer to the created array.<br><br>

<span class=c_code>
<span class=c5>// Insert variable into array</span><br>
param_data * array_insert_new_var(<span class=c2>const</span> <span class=c4>std::string</span> &sKey);<br><br>
</span>

<span class=c_code>
<span class=c5>// Insert hash into array</span><br>
param_data * array_insert_new_hash();<br><br>
</span>

<span class=c_code>
<span class=c5>// Removes variable from hash</span><br>
void param_data::hash_erase_var(<span class=c2>const</span> <span class=c4>std::string</span> &sKey);<br><br>
</span>

<span class=c_code>
<span class=c5>// Destructor</span><br>
~param_data();<br><br>
</span>

<hr width=90% noshade>
<small>Copyright &copy; 2003 - 2005 CTPP Dev. Team | <a href=http://www.reki.ru/products/ctpp>http://reki.ru/products/ctpp</a></small>
</body>
</html>
